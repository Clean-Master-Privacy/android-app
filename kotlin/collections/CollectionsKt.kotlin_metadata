// IntelliJ API Decompiler stub source generated from a class file
// Implementation of methods is not available

package kotlin.collections

public val kotlin.collections.Collection<*>.indices: kotlin.ranges.IntRange /* compiled code */
    public final get

public val <T> kotlin.collections.List<T>.lastIndex: kotlin.Int /* compiled code */
    public final get

@kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun <T> List(size: kotlin.Int, init: (kotlin.Int) -> T): kotlin.collections.List<T> { /* compiled code */ }

@kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun <T> MutableList(size: kotlin.Int, init: (kotlin.Int) -> T): kotlin.collections.MutableList<T> { /* compiled code */ }

@kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun <T> arrayListOf(): kotlin.collections.ArrayList<T> { /* compiled code */ }

public fun <T> arrayListOf(vararg elements: T): kotlin.collections.ArrayList<T> { /* compiled code */ }

public fun <T> emptyList(): kotlin.collections.List<T> { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> listOf(): kotlin.collections.List<T> { /* compiled code */ }

public fun <T> listOf(vararg elements: T): kotlin.collections.List<T> { /* compiled code */ }

public fun <T : kotlin.Any> listOfNotNull(element: T?): kotlin.collections.List<T> { /* compiled code */ }

public fun <T : kotlin.Any> listOfNotNull(vararg elements: T?): kotlin.collections.List<T> { /* compiled code */ }

@kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun <T> mutableListOf(): kotlin.collections.MutableList<T> { /* compiled code */ }

public fun <T> mutableListOf(vararg elements: T): kotlin.collections.MutableList<T> { /* compiled code */ }

private fun rangeCheck(size: kotlin.Int, fromIndex: kotlin.Int, toIndex: kotlin.Int): kotlin.Unit { /* compiled code */ }

internal fun <T> kotlin.Array<out T>.asCollection(): kotlin.collections.Collection<T> { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.binarySearch(element: T, comparator: kotlin.Comparator<in T>, fromIndex: kotlin.Int = COMPILED_CODE, toIndex: kotlin.Int = COMPILED_CODE): kotlin.Int { /* compiled code */ }

public fun <T> kotlin.collections.List<T>.binarySearch(fromIndex: kotlin.Int = COMPILED_CODE, toIndex: kotlin.Int = COMPILED_CODE, comparison: (T) -> kotlin.Int): kotlin.Int { /* compiled code */ }

public fun <T : kotlin.Comparable<T>> kotlin.collections.List<T?>.binarySearch(element: T?, fromIndex: kotlin.Int = COMPILED_CODE, toIndex: kotlin.Int = COMPILED_CODE): kotlin.Int { /* compiled code */ }

public inline fun <T, K : kotlin.Comparable<K>> kotlin.collections.List<T>.binarySearchBy(key: K?, fromIndex: kotlin.Int = COMPILED_CODE, toIndex: kotlin.Int = COMPILED_CODE, crossinline selector: (T) -> K?): kotlin.Int { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <@kotlin.internal.OnlyInputTypes T> kotlin.collections.Collection<T>.containsAll(elements: kotlin.collections.Collection<T>): kotlin.Boolean { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.Collection<T>.isNotEmpty(): kotlin.Boolean { /* compiled code */ }

internal fun <T> kotlin.collections.List<T>.optimizeReadOnlyList(): kotlin.collections.List<T> { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.Collection<T>?.orEmpty(): kotlin.collections.Collection<T> { /* compiled code */ }

@kotlin.internal.InlineOnly public inline fun <T> kotlin.collections.List<T>?.orEmpty(): kotlin.collections.List<T> { /* compiled code */ }

